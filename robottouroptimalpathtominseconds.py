# -*- coding: utf-8 -*-
"""RobotTourOptimalPathToMinSeconds

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/195lUrN3yU92Bt51KLnxyJZejMOjFnuIp
"""

from heapq import heappush, heappop
from typing import List, Tuple, Dict, Optional

class Cell:
    def __init__(self):
        self.walls = {'N': False, 'E': False, 'S': False, 'W': False}
        self.is_gate = None

class State:
    def __init__(
        self,
        pos: Tuple[int, int],
        direction: int,  # 0: north, 1: east, 2: south, 3: west
        current_gate: Optional[str],
        gates_status: Dict[str, bool],
        gates_sequence: Tuple[str, ...]
    ):
        self.pos = pos
        self.direction = direction
        self.current_gate = current_gate
        self.gates_status = gates_status
        self.gates_sequence = gates_sequence

    def __eq__(self, other):
        return (
            self.pos == other.pos and
            self.direction == other.direction and
            self.current_gate == other.current_gate and
            self.gates_status == other.gates_status and
            self.gates_sequence == other.gates_sequence
        )

    def __hash__(self):
        return hash((
            self.pos,
            self.direction,
            self.current_gate,
            frozenset(self.gates_status.items()),
            self.gates_sequence
        ))

def get_manhattan_distance(pos1: Tuple[int, int], pos2: Tuple[int, int]) -> int:
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

def get_turn_count(current_direction: int, target_direction: int) -> int:
    diff = (target_direction - current_direction) % 4
    return min(diff, 4 - diff)

def get_turns(current_direction: int, new_direction: int) -> List[str]:
    """
    Utility function to convert a direction change into a sequence of turn actions
    (L, R, or R,R if it's a 2-step turn).
    """
    delta = (new_direction - current_direction) % 4
    if delta == 0:
        return []
    elif delta == 1:
        return ['R']
    elif delta == 2:
        return ['R', 'R']  # U-turn
    elif delta == 3:
        return ['L']

def find_optimal_path(
    maze: List[List[Cell]],
    start: Tuple[int, int],
    end: Tuple[int, int],
    gates: Dict[str, Tuple[int, int]],
    last_gate: str,
    initial_direction: int
) -> Tuple[Optional[List[Tuple[Tuple[int, int], Optional[str], int, Optional[str]]]], Optional[Tuple[str, ...]]]:
    """
    This function performs an A* (or Dijkstra if heuristic=0) search over the maze to find the path
    that visits all gates in any order but ensures 'last_gate' is visited last, ending at 'end' position.
    There's no backward movement; U-turn is allowed as a discrete action 'U'.

    It returns:
        (path, gates_sequence)
    where:
        path is a list of (pos, current_gate, direction, move_action),
        gates_sequence is the tuple of gates visited in the order they were visited.
    """

    rows, cols = len(maze), len(maze[0])

    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    dir_labels = ['N', 'E', 'S', 'W']

    # Movement and turn costs
    MOVE_COST = 1.21
    TURN_COST = 0.65
    UTURN_COST = 2 * TURN_COST

    def is_in_bounds(r: int, c: int) -> bool:
        return 0 <= r < rows and 0 <= c < cols

    def wall_blocks_move(r_from: int, c_from: int, r_to: int, c_to: int) -> bool:
        if not is_in_bounds(r_from, c_from):
            return not ((r_from, c_from) == start)
        if not is_in_bounds(r_to, c_to):
            if (r_to, c_to) != end:
                return True
            return False

        cell_from = maze[r_from][c_from]
        cell_to = maze[r_to][c_to]
        dr = r_to - r_from
        dc = c_to - c_from

        if dr == -1 and dc == 0:
            dir_label_from = 'N'
            dir_label_to = 'S'
        elif dr == 1 and dc == 0:
            dir_label_from = 'S'
            dir_label_to = 'N'
        elif dr == 0 and dc == 1:
            dir_label_from = 'E'
            dir_label_to = 'W'
        elif dr == 0 and dc == -1:
            dir_label_from = 'W'
            dir_label_to = 'E'
        else:
            return True

        if cell_from.walls.get(dir_label_from, False):
            return True
        if cell_to.walls.get(dir_label_to, False):
            return True
        return False

    def check_gates_transition(
        pos_from: Tuple[int, int],
        pos_to: Tuple[int, int],
        gates_status_before: Dict[str, bool],
        gates_sequence_before: Tuple[str, ...],
        current_gate_before: Optional[str]
    ) -> Tuple[Optional[str], Dict[str, bool], Tuple[str, ...]]:

        r_from, c_from = pos_from
        r_to, c_to = pos_to

        new_current_gate = current_gate_before
        new_gates_status = gates_status_before.copy()
        new_gates_sequence = list(gates_sequence_before)

        cell_from = maze[r_from][c_from] if is_in_bounds(r_from, c_from) else None
        cell_to = maze[r_to][c_to] if is_in_bounds(r_to, c_to) else None
        gate_from = cell_from.is_gate if cell_from else None
        gate_to = cell_to.is_gate if cell_to else None

        if gate_from != gate_to:

            if gate_from is not None and not new_gates_status[gate_from]:
                new_gates_status[gate_from] = True
                new_gates_sequence.append(gate_from)
            new_current_gate = gate_to

        return new_current_gate, new_gates_status, tuple(new_gates_sequence)

    def all_other_gates_visited(gates_status: Dict[str, bool], last_gate: str) -> bool:
        """ True if all gates except last_gate are visited. """
        for g in gates_status:
            if g != last_gate and not gates_status[g]:
                return False
        return True

    def get_next_states(current_state: State) -> List[Tuple[State, float, str]]:

        next_states = []
        r, c = current_state.pos
        d = current_state.direction

        new_dir = (d - 1) % 4
        cost = TURN_COST
        new_state = State(
            current_state.pos,
            new_dir,
            current_state.current_gate,
            current_state.gates_status,
            current_state.gates_sequence
        )
        next_states.append((new_state, cost, 'L'))

        new_dir = (d + 1) % 4
        cost = TURN_COST
        new_state = State(
            current_state.pos,
            new_dir,
            current_state.current_gate,
            current_state.gates_status,
            current_state.gates_sequence
        )
        next_states.append((new_state, cost, 'R'))

        new_dir = (d + 2) % 4
        cost = UTURN_COST
        new_state = State(
            current_state.pos,
            new_dir,
            current_state.current_gate,
            current_state.gates_status,
            current_state.gates_sequence
        )
        next_states.append((new_state, cost, 'U'))

        dr, dc = directions[d]
        nr, nc = r + dr, c + dc
        if not wall_blocks_move(r, c, nr, nc):
            move_cost = MOVE_COST
            (new_current_gate, new_gates_status, new_gates_sequence) = check_gates_transition(
                (r, c),
                (nr, nc),
                current_state.gates_status,
                current_state.gates_sequence,
                current_state.current_gate
            )

            if new_gates_status[last_gate]:
                if not all_other_gates_visited(new_gates_status, last_gate):
                    pass
                else:
                    new_state = State(
                        (nr, nc),
                        d,
                        new_current_gate,
                        new_gates_status,
                        new_gates_sequence
                    )
                    next_states.append((new_state, move_cost, 'F'))
            else:
                new_state = State(
                    (nr, nc),
                    d,
                    new_current_gate,
                    new_gates_status,
                    new_gates_sequence
                )
                next_states.append((new_state, move_cost, 'F'))

        return next_states

    def heuristic(state: State) -> float:
        return 0

    initial_gates_status = {gate: False for gate in gates}
    start_state = State(
        start,
        initial_direction,
        None,
        initial_gates_status,
        ()
    )
    pq = []
    counter = 0
    heappush(pq, (0, 0, counter, start_state))
    came_from = {}
    move_taken = {}
    g_score = {start_state: 0}
    counter += 1

    path = None
    gates_sequence = None

    while pq:
        _, current_g, _, current_state = heappop(pq)

        if (current_state.pos == end and
            all(current_state.gates_status[g] for g in gates)):
            path = []
            cs = current_state
            while cs in came_from:
                move = move_taken[cs]
                path.append((cs.pos, cs.current_gate, cs.direction, move))
                cs = came_from[cs]
            path.append((start_state.pos, start_state.current_gate, start_state.direction, None))
            path.reverse()
            gates_sequence = current_state.gates_sequence
            break

        for nxt, cost, move in get_next_states(current_state):
            tentative_g = current_g + cost
            if nxt not in g_score or tentative_g < g_score[nxt]:
                came_from[nxt] = current_state
                move_taken[nxt] = move
                g_score[nxt] = tentative_g
                f_score = tentative_g + heuristic(nxt)
                heappush(pq, (f_score, tentative_g, counter, nxt))
                counter += 1

    if path:
        return (path, gates_sequence)
    else:
        return (None, None)

def verify_path(maze, start_pos, end, start_direction, actions, gates, last_gate):
    rows, cols = len(maze), len(maze[0])
    pos = start_pos
    direction = start_direction
    gates_status = {gate: False for gate in gates}
    gates_sequence = []

    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    dir_labels = ['N', 'E', 'S', 'W']

    def is_in_bounds(r, c):
        return 0 <= r < rows and 0 <= c < cols

    idx = 0
    while idx < len(actions):
        action = actions[idx]

        if action == 'S':
            idx += 1
            continue
        elif action == 'L':
            direction = (direction - 1) % 4
            idx += 1
        elif action == 'R':
            direction = (direction + 1) % 4
            idx += 1
        elif action == 'U':
            direction = (direction + 2) % 4
            idx += 1
        elif action in ['F', 'E']:
            if action == 'F':
                dr, dc = directions[direction]
            else:
                dr, dc = directions[direction]

            nr, nc = pos[0] + dr, pos[1] + dc
            new_pos = (nr, nc)

            if not (is_in_bounds(nr, nc) or new_pos == end):
                print(f"Verification failed: Invalid move from {pos} to {new_pos}")
                return False

            if is_in_bounds(pos[0], pos[1]):
                current_cell = maze[pos[0]][pos[1]]
            else:
                current_cell = None

            if is_in_bounds(nr, nc):
                new_cell = maze[nr][nc]
            else:
                new_cell = None

            dir_label_from = dir_labels[direction]

            if dir_label_from == 'N':
                dir_label_to = 'S'
            elif dir_label_from == 'S':
                dir_label_to = 'N'
            elif dir_label_from == 'E':
                dir_label_to = 'W'
            else:
                dir_label_to = 'E'

            if current_cell is not None:
                if current_cell.walls.get(dir_label_from, False):
                    print(f"Verification failed: Wall blocks movement at {pos}")
                    return False
            if new_cell is not None:
                if new_cell.walls.get(dir_label_to, False):
                    print(f"Verification failed: Wall blocks movement into {new_pos}")
                    return False

            if current_cell and current_cell.is_gate:
                gate_label = current_cell.is_gate
                if not gates_status[gate_label]:
                    gates_status[gate_label] = True
                    gates_sequence.append(gate_label)

            pos = new_pos
            idx += 1

            if action == 'E':
                if pos != end:
                    print(f"Verification failed: Final 'E' did not land on end. Current: {pos}, End: {end}")
                    return False
                break
        else:

            idx += 1

    if pos != end:
        print(f"Verification failed: Final position {pos} does not match end {end}")
        return False

    if not all(gates_status.values()):
        print(f"Verification failed: Not all gates visited. Status: {gates_status}")
        return False

    if gates_sequence and gates_sequence[-1] != last_gate:
        print(f"Verification failed: Last gate {gates_sequence[-1]} is not the required last gate {last_gate}")
        return False

    return True

def create_maze():
    rows, cols = 6, 7
    maze = [[Cell() for _ in range(cols)] for _ in range(rows)]

    #(1,1) (1,2) (1,3) (1,4) (1,5)
    #(2,1) (2,2) (2,3) (2,4) (2,5)
    #(3,1) (3,2) (3,3) (3,4) (3,5)
    #(4,1) (4,2) (4,3) (4,4) (4,5)

    # Gates positions
    gates = {
        'A': (4, 2),
        'B': (1, 3),
        'C': (2, 5),
        'D': (1, 2),
        'E': (1, 1) #last
    }

    #(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (0,6)
    #(1,0) (1,1) (1,2) (1,3) (1,4) (1,5) (1,6)
    #(2,0) (2,1) (2,2) (2,3) (2,4) (2,5) (2,6)
    #(3,0) (3,1) (3,2) (3,3) (3,4) (3,5) (3,6)
    #(4,0) (4,1) (4,2) (4,3) (4,4) (4,5) (4,6)
    #(5,0) (5,1) (5,2) (5,3) (5,4) (5,5) (5,6)

    barriers = [
        # These are the outside ones that prevent the robot from going into the "outer square".
        # Comment out the one from where the robot has to enter from.
        ((0, 1), 'S'),
        ((0, 2), 'S'),
        ((0, 3), 'S'),
        ((0, 4), 'S'),
        ((0, 5), 'S'),
        ((5, 1), 'N'),
        ((5, 2), 'N'),
        #((5, 3), 'N'),
        ((5, 4), 'N'),
        ((5, 5), 'N'),
        ((1, 0), 'E'),
        ((2, 0), 'E'),
        ((3, 0), 'E'),
        ((4, 0), 'E'),
        ((1, 6), 'W'),
        ((2, 6), 'W'),
        ((3, 6), 'W'),
        ((4, 6), 'W'),
        # End of the outside walls

        # Inside barriers
        ((4, 2), 'N'),
        ((4, 2), 'E'),
        ((4, 3), 'N'),
        ((4, 4), 'E'),
        ((2, 2), 'W'),
        ((2, 2), 'S'),
        ((2, 3), 'N'),
        ((2, 4), 'E'),
        ((1, 1), 'E'),
        ((1, 2), 'E'),
    ]

    #(1,1) (1,2) (1,3) (1,4) (1,5)
    #(2,1) (2,2) (2,3) (2,4) (2,5)
    #(3,1) (3,2) (3,3) (3,4) (3,5)
    #(4,1) (4,2) (4,3) (4,4) (4,5)

    for (r, c), direction in barriers:
        maze[r][c].walls[direction] = True
        if direction == 'N' and r > 0:
            maze[r-1][c].walls['S'] = True
        elif direction == 'E' and c < cols - 1:
            maze[r][c+1].walls['W'] = True
        elif direction == 'S' and r < rows - 1:
            maze[r+1][c].walls['N'] = True
        elif direction == 'W' and c > 0:
            maze[r][c-1].walls['E'] = True

    start = (4, 3)
    end = (4, 5)
    last_gate = 'E'

    #(0,0) (0,1) (0,2) (0,3) (0,4) (0,5) (0,6)
    #(1,0) (1,1) (1,2) (1,3) (1,4) (1,5) (1,6)
    #(2,0) (2,1) (2,2) (2,3) (2,4) (2,5) (2,6)
    #(3,0) (3,1) (3,2) (3,3) (3,4) (3,5) (3,6)
    #(4,0) (4,1) (4,2) (4,3) (4,4) (4,5) (4,6)
    #(5,0) (5,1) (5,2) (5,3) (5,4) (5,5) (5,6)

    for gate_label, (r, c) in gates.items():
        maze[r][c].is_gate = gate_label

    return maze, start, end, gates, last_gate

def print_grid(maze, start, end):
    rows, cols = len(maze), len(maze[0])

    min_row = min(0, start[0])
    max_row = max(rows - 1, start[0])
    min_col = min(0, start[1])
    max_col = max(cols - 1, start[1])

    print("Grid Coordinates:")
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            print(f"({r},{c})", end=' ')
        print()
    print()

    for r in range(min_row, max_row + 1):
        cell_line = ''
        for c in range(min_col, max_col + 1):
            if (0 <= r < rows) and (0 <= c < cols):
                cell = maze[r][c]
                if (r, c) == start and (r, c) == end:
                    cell_char = 'S/E'
                elif (r, c) == start:
                    cell_char = 'S'
                elif (r, c) == end:
                    cell_char = 'E'
                elif cell.is_gate is not None:
                    cell_char = cell.is_gate
                else:
                    cell_char = '.'
                cell_line += f"{cell_char}"
                if c < max_col:
                    if c < cols - 1 and cell.walls['E']:
                        cell_line += '|'
                    else:
                        cell_line += ' '
            else:
                cell_line += ' '
                if c < max_col:
                    cell_line += ' '
        print(cell_line)

        if r < max_row:
            wall_line = ''
            for c in range(min_col, max_col + 1):
                if (0 <= r < rows - 1) and (0 <= c < cols):
                    cell = maze[r][c]
                    if cell.walls['S']:
                        wall_line += '— '
                    else:
                        wall_line += '  '
                else:
                    wall_line += '  '
            print(wall_line)
    print()

def main():
    maze, start, end, gates, last_gate = create_maze()
    print("Maze layout:")
    print_grid(maze, start, end)

    initial_direction = 0

    path, gates_sequence = find_optimal_path(
        maze,
        start,
        end,
        gates,
        last_gate,
        initial_direction
    )

    if path:
        print("Optimal path found:")
        for pos, gate, direction, move in path:
            dir_map = {0: 'N', 1: 'E', 2: 'S', 3: 'W'}
            dir_str = dir_map[direction]
            move_str = move if move else 'S'
            if gate:
                print(f"{pos} (Gate {gate}) facing {dir_str}, via {move_str}")
            else:
                print(f"{pos} facing {dir_str}, via {move_str}")

        action_list = []
        MOVE_COST = 1.21
        TURN_COST = 0.65
        UTURN_COST = 2 * TURN_COST
        total_time = 0.0

        for i in range(len(path)):
            if i == 0:
                action_list.append('S')
                continue
            current_pos, current_gate, current_direction, move = path[i]
            if move in ['L', 'R']:
                action_list.append(move)
                total_time += TURN_COST
            elif move == 'U':
                action_list.append('R')
                action_list.append('R')
                total_time += UTURN_COST
            elif move == 'F':
                action_list.append('F')
                total_time += MOVE_COST
            elif move is None:
                pass

        if len(action_list) > 1 and action_list[-1] == 'F':
            action_list[-1] = 'E'
        else:
            action_list.append('E')
        total_time += MOVE_COST

        print("\nActions:")
        print(' '.join(action_list))

        total_forward = action_list.count('F')
        total_turn_left = action_list.count('L')
        total_turn_right = action_list.count('R')
        total_uturn = 0
        total_forward_with_end = total_forward + action_list.count('E')

        total_moves = len(action_list)
        total_turns = total_turn_left + total_turn_right + (2 * total_uturn)

        print(f"\nTotal forward movements: {total_forward_with_end}")
        print(f"Total turns (incl. U-turns): {total_turns}")
        print(f"Total moves (movements + turns): {total_moves}")
        print(f"Order of gates visited: {gates_sequence}")
        is_valid = verify_path(maze, start, end, initial_direction, action_list, gates, last_gate)
        print(f"\nPath verification: {'Valid' if is_valid else 'Invalid'}")
        print(f"Total time needed: {total_time:.2f} seconds")
    else:
        print("No valid path found!")

if __name__ == "__main__":
    main()

